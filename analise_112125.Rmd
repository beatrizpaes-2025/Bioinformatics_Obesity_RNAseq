---
title: "GSE112125"
author: "BEATRIZPAES"
date: "2025-07-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
Análise de Gene ID e Anotação:
# Carregar pacotes necessários para anotação
# Se você ainda não os tem, instale-os primeiro:
# if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
# BiocManager::install("AnnotationDbi")
# BiocManager::install("org.Mm.eg.db") # Para Mus musculus
library(AnnotationDbi)
# 1. Instalar BiocManager (se ainda não estiver instalado)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# 2. Instalar os pacotes do Bioconductor necessários
BiocManager::install("AnnotationDbi")
# Certifique-se de que os pacotes necessários estão carregados
library(AnnotationDbi)
library(org.Mm.eg.db) # Banco de dados de anotação para Mus musculus
library(DESeq2)
# Carregar dados completos
counts <- read.table("GSE136821_mergedcounts.txt.gz", header = TRUE, row.names = 1)
getwd()
# Deve retornar: "/mnt/d/bioinformatica/GEO/GSM4058638"
setwd("D:/bioinformatica/GEO/GSM4058638")
setwd("/mnt/d/bioinformatica/GEO/GSM4058638")
setwd("D:/bioinformatica/GEO/GSM4058638")
counts <- read.table("D:/bioinformatica/GEO/GSM4058638/GSE136821_mergedcounts.txt.gz",
header = TRUE,
row.names = 1)
# Identificar colunas de interesse
chow_cols <- grep("Chow", colnames(counts), value = TRUE)
hfd_cols <- grep("HFD", colnames(counts), value = TRUE)
# Criar matriz reduzida
count_subset <- counts[, c(chow_cols, hfd_cols)]
colData <- data.frame(
condition = factor(c(rep("Chow", length(chow_cols)),
rep("HFD", length(hfd_cols)))),
row.names = colnames(count_subset)
)
dds <- DESeqDataSetFromMatrix(
countData = count_subset,
colData = colData,
design = ~ condition
)
dds <- DESeq(dds)
results <- results(dds)
# 1.1. Inspeção do Tamanho da Biblioteca (Contagens totais por amostra)
cat("Contagens totais por amostra (tamanho da biblioteca):\n")
print(colSums(counts(dds)))
# 1.2. Transformação dos dados para Análise de Componentes Principais (PCA)
# A função vst (variance stabilizing transformation) é ideal para dados de RNA-seq para PCA.
cat("\nRealizando transformação dos dados (vst) para PCA...\n")
vsd <- vst(dds, blind = FALSE) # blind=FALSE usa o design ~ condition na transformação
# 1.3. Análise de Componentes Principais (PCA)
# Gere o gráfico de PCA para ver como as amostras se agrupam pela condição.
cat("Gerando o gráfico de PCA. Por favor, visualize-o no painel 'Plots' do RStudio.\n")
plotPCA(vsd, intgroup = "condition")
# Para salvar a PCA em um arquivo (opcional)
# ggsave("pca_plot_GSE136821.png", plot = last_plot(), width = 8, height = 6, dpi = 300)
# 2.1. Obter os resultados da análise DESeq2
# 'alpha = 0.05' define o limiar para o p-valor ajustado (padj).
cat("Obtendo e ordenando os resultados da análise DESeq2...\n")
res <- results(dds, alpha = 0.05)
res_ordered <- res[order(res$padj), ]
# 2.2. Visualizar um resumo dos resultados
cat("\nResumo dos resultados da análise de expressão diferencial:\n")
summary(res)
# 2.3. Filtrar DEGs com base nos critérios de significância e magnitude
# padj < 0.05: p-valor ajustado menor que 0.05 (significância estatística)
# abs(log2FoldChange) > 1: mudança de expressão de pelo menos 2x (magnitude biológica)
cat("\nFiltrando Genes Diferencialmente Expressos (DEGs) com padj < 0.05 e |log2FoldChange| > 1...\n")
sig_genes <- subset(res_ordered, padj < 0.05 & abs(log2FoldChange) > 1)
# 2.4. Exibir o número de DEGs encontrados
cat(paste("\nNúmero de DEGs significativos encontrados:", nrow(sig_genes), "\n"))
# 2.5. Exibir os primeiros 10 DEGs mais significativos
cat("\nPrimeiros 10 DEGs mais significativos:\n")
print(head(sig_genes, 10))
# 2.6. Opcional: Salvar a lista completa de DEGs significativos em um arquivo CSV
# write.csv(as.data.frame(sig_genes), file = "DEGs_GSE136821_HFD_vs_Chow.csv")
# cat("\nLista de DEGs significativos salva em 'DEGs_GSE136821_HFD_vs_Chow.csv'\n")
# Exemplo de código para mapeamento (certifique-se de instalar o pacote org.Mm.eg.db se ainda não o tiver)
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("org.Mm.eg.db") # Pode demorar um pouco
# BiocManager::install("AnnotationDbi")
library(AnnotationDbi)
library(org.Mm.eg.db)
# Mapear IDs Ensembl para símbolos de genes
sig_genes$symbol <- mapIds(org.Mm.eg.db,
keys=row.names(sig_genes),
column="SYMBOL",
keytype="ENSEMBL",
multiVals="first")
# Verifique se o mapeamento funcionou
cat("\nPrimeiros 10 DEGs com símbolos de genes:\n")
print(head(sig_genes[, c("log2FoldChange", "padj", "symbol")], 10))
# Visualizar toda a tabela no RStudio (cuidado: 1892 linhas!)
View(sig_genes)
# Exportar para CSV (execute sem o #)
write.csv(as.data.frame(sig_genes),
file = "DEGs_GSE136821_HFD_vs_Chow.csv")
setwd("D:/bioinformatica/GEO/GSE112125")
download.file("https://ftp.ncbi.nlm.nih.gov/geo/series/GSE112nnn/GSE112125/suppl/GSE112125_Todos_genes.Leptina_RNA.xlsx",
destfile = "GSE112125_RNA_data.xlsx")
# Nome correto do arquivo (note "All_genes" e "Leptin" em vez de "Todos_genes" e "Leptina")
download.file("https://ftp.ncbi.nlm.nih.gov/geo/series/GSE112nnn/GSE112125/suppl/GSE112125_All_genes.Leptin_RNA.xlsx",
destfile = "GSE112125_RNA_data.xlsx",
mode = "wb")
# Instalar pacote para leitura de Excel (se necessário)
if (!require("readxl")) install.packages("readxl")
library(readxl)
# Carregar dados de expressão gênica
rna_data <- read_excel("GSE112125_RNA_data.xlsx", sheet = 1)
# Inspecionar estrutura dos dados
head(rna_data[, 1:5])  # Ver primeiras colunas
colnames(rna_data)      # Identificar amostras e metadados
dim(rna_data)           # Verificar número de genes e amostras
# Filtrar colunas relevantes para análise comparativa:
# FedSSSGFPn (controle) vs FasLLLGFPn (modelo metabólico)
samples_to_keep <- grep("FedSSSGFPn|FasLLLGFPn", colnames(rna_data), value = TRUE)
count_matrix <- rna_data[, c("Gene_ID", samples_to_keep)]
# Filtrar amostras e selecionar colunas corretas:
count_matrix <- rna_data[, c("Ensembl_ID",
grep("\.norm$", samples_to_keep, value = TRUE))]
# 1. Corrigir o nome da coluna de identificação do gene
colnames(rna_data)[1] <- "Ensembl_ID"
# 2. Selecionar apenas colunas com dados normalizados (.norm)
samples_norm <- grep("FedSSSGFPn|FasLLLGFPn",
grep("\.norm$", colnames(rna_data), value = TRUE),
samples_norm <- grep("FedSSSGFPn|FasLLLGFPn",
grep("\\.norm$", colnames(rna_data), value = TRUE),
value = TRUE)
count_matrix <- rna_data[, c("Ensembl_ID", samples_norm)]
colnames(count_matrix) <- gsub("\\.norm$", "", colnames(count_matrix))
# Criar metadados
condition <- ifelse(grepl("FasLLL", colnames(count_matrix)[-1]), "Fasted", "Fed")
colData <- data.frame(
sampleID = colnames(count_matrix)[-1],
condition = factor(condition)
)
# Converter para matriz de expressão
expr_matrix <- as.matrix(count_matrix[, -1])
rownames(expr_matrix) <- count_matrix$Ensembl_ID
# Criar design matrix
design <- model.matrix(~ condition, data = colData)
# Análise limma-voom
library(limma)
v <- voom(expr_matrix, design, plot = TRUE)
fit <- lmFit(v, design)
fit <- eBayes(fit)
# Extrair DEGs
deg_table <- topTable(fit, coef = 2, number = Inf)
# Plot MA para verificação de qualidade
plotMA(fit)
library(org.Mm.eg.db)
sig_genes_annot <- AnnotationDbi::select(org.Mm.eg.db,
keys = rownames(sig_degs),
columns = c("SYMBOL", "GENENAME"),
keytype = "ENSEMBL")
# Gerar dataframe com estatísticas relevantes
deg_table_formatted <- data.frame(
baseMean = 2^deg_table$AveExpr,         # Converter de log2 para linear scale
log2FoldChange = deg_table$logFC,
lfcSE = sqrt(deg_table$s2.post),        # Usando variância posterior como estimativa SE
stat = deg_table$t,
pvalue = deg_table$P.Value,
padj = deg_table$adj.P.Val,
symbol = mapIds(org.Mm.eg.db,
keys = rownames(deg_table),
column = "SYMBOL",
keytype = "ENSEMBL",
multiVals = "first")
)
# Corrigir cálculo do lfcSE usando estatística t
deg_table_formatted <- data.frame(
baseMean = 2^deg_table$AveExpr,
log2FoldChange = deg_table$logFC,
lfcSE = abs(deg_table$logFC / deg_table$t),  # SE = |logFC/t|
stat = deg_table$t,
pvalue = deg_table$P.Value,
padj = deg_table$adj.P.Val,
symbol = mapIds(org.Mm.eg.db,
keys = rownames(deg_table),
column = "SYMBOL",
keytype = "ENSEMBL",
multiVals = "first")
)
# Obter todos os símbolos possíveis
symbols_list <- mapIds(org.Mm.eg.db,
keys = rownames(deg_table),
column = "SYMBOL",
keytype = "ENSEMBL",
multiVals = "list")
# Colapsar múltiplos símbolos em string única
deg_table_formatted$symbol <- sapply(symbols_list,
function(x) paste(unique(x), collapse = ";"))
deg_table_formatted <- deg_table_formatted[!grepl(";", deg_table_formatted$symbol), ]
